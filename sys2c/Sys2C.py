#!/usr/bin/python

import sys, getopt
import operator
import ntpath
import math
import pdb
import time
import re

sysFile = ['open', 'openat', 'creat', 'stat', 'lstat', 'fstat', 'read', 'write', 
           'close', 'lseek', 'fcntl', 'chmod', 'fchmod', 'fchmodat']
sysMem = ['mmap', 'munmap', 'mprotect']
sysNet = ['accept', 'bind', 'connect', 'close', 'getsockname', 'getsockopt', 
          'listen', 'read', 'recv', 'select', 'send', 'shutdown', 'socket']

testfile = ".testfile"
notexistsfile = ".notexistsfile"

cfilehead = "/* Don't modify!! Automaticly generated by Sys2C.py. */\n\
#include <stdlib.h>\n\
/* for file management syscall */ \n\
#include <sys/types.h>\n\
#include <sys/stat.h>\n\
#include <fcntl.h>\n\
#include <unistd.h>\n\
/* for memory syscall */ \n\
#include <sys/mman.h>\n\
int main(void){\n\
/* syscall begin */\n"
cfiletail = "/* syscall end */\nreturn 0;\n}"

def writeHisto(outHisto, outputFP):
    outputFP.write("{:12s}{:12s}{:12s}\t{:12s}\n" .format('HISTO:', 'syscall', 'times', 'seconds'))
    for keyT, valT in outHisto.items():
        sortedTable = sorted(valT.items(), key=operator.itemgetter(0), reverse=False)
        #print(sortedTable)
        for item in sortedTable:
            outputFP.write("{:12s}{:12s}{:10d}\t{:12s}\n" .format('HISTO:', keyT, item[1], item[0]))

def line2c(sysname, func, retvalue, retdata):
    funcline = ""
    timestr = re.sub("\.", "_", "%f" % time.time())

    #pdb.set_trace()
    if "openfd" in retdata.keys():
        openfd = retdata["openfd"]
    else:
        openfd = 255 # use a fake fd if not comes from open
    if "mmapaddr" in retdata.keys():
        mmapaddr = retdata["mmapaddr"]

    if "open" == sysname or "openat" == sysname:
        # fd = open("/sys/devices/system/cpu/online", O_RDONLY|O_CLOEXEC);
        func = re.sub("\"(.*)\"", "\"%s\"" % testfile, func)
        if retvalue != -1:
            # set openfd for other syscalls
            openfd = "fd_%s" % timestr
            retdata["openfd"] = openfd
            funcline = "int %s = %s;\n" % (openfd, func)
        else:
            # ret = -1
            func = re.sub("\"(.*)\"", "\"%s\"" % notexistsfile, func)
            funcline = "%s;\n" % func
    elif "stat" == sysname or "lstat" == sysname: 
        statfile = re.search("\"(.*)\"", func)
        # struct stat sb; stat("/usr/lib64/mpich/lib", &sb);
        funcline = "struct stat sb; %s(%s, \&sb);\n" % (sysname, statfile)
    elif "fstat" == sysname: 
        # struct stat sb; fstat(fd, &sb);
        funcline = "struct stat sb; %s(%s, \&sb);\n" % (sysname, openfd)
    elif "read" == sysname or "write" == sysname: 
        # char buf[SIZE]; read(fd, buf, SIZE);
        # char buf[SIZE]; write(fd, buf, 4);
        funcline = "char buf_%s[%d]; %s(%s, buf_%s, %d);\n" % (timestr, retvalue, sysname, openfd, timestr, retvalue)
        # if re.search('(\(0\,|\(1\,|\(2\,|\(255\,)', func):
        #    funcline = "%s;\n" % func
    elif "close" == sysname: 
        # close(fd);
        # 0 for stdin, 1 for stdout and 2 for stderr, and 255 for terminal I/O
        if re.search('(\(0\)|\(1\)|\(2\)|\(255\))', func):
            funcline = "%s;\n" % func
        else:
            funcline = "%s(%s);\n" % (sysname, openfd)
            retdata.pop("openfd", None) # remove the openfd after closed
    elif "lseek" == sysname or "fcntl" == sysname or "chmod" == sysname:
        # lseek(3, 64428565, SEEK_SET);
        # fcntl(3, F_SETFD, FD_CLOEXEC);
        # 0 for stdin, 1 for stdout and 2 for stderr, and 255 for terminal I/O
        if re.search('(\(0\,|\(1\,|\(2\,|\(255\,)', func):
            funcline = "%s;\n" % func
        else:
            funcline = "%s;\n" % re.sub("\([0-9]*\,", "(%s," % openfd, func)
    elif "chmod" == sysname: 
        # chmod("/tmp/hadoop-yuyuzhou/mapred/staging/yuyuzhou1978181875/.staging", 0700)
        funcline = "%s;\n" % re.sub("\"(.*)\"", "\"%s\"" % testfile, func)
    elif "mmap" == sysname: 
        # char *char; char = mmap(NULL, 97021, PROT_READ, MAP_PRIVATE, 3, 0);
        mmapaddr = "addr_%s" % timestr
        retdata["mmapaddr"] = mmapaddr
        func = re.sub("\(0x[0-9]*\,", "(NULL," % openfd, func)
        funcline = "char *%s; %s = %s;\n" % (mmapaddr, mmapaddr, func)
    elif "munmap" == sysname: 
        # munmap(0x7f146bd6f000, 97021);
        funcline = "%s;\n" % re.sub("\(0x[0-9]*\,", "(%s," % mmapaddr, func) 
    elif "mprotect" == sysname: 
        # mprotect(0x3c00e0a000, 2093056, PROT_NONE);
        funcline = "%s;\n" % func
    #elif "creat" == sysname: 
    #elif "fchmod" == sysname: 
    #elif "fchmodat" == sysname: 
        
    return retdata, funcline


def parseline(line, sysCall, sysdata, retdata):
    cline = ""

    pid = line[0:5]
    if pid not in retdata:
        retdata[pid] = {} # each pid has it's own openfd, mmapaddr, and etc.
    
    if "unfinished" in line:
        print "unfinished found: %s" % line

    else:
        #pdb.set_trace()
        cols = line.split(' = ')
        retvalue = cols[1].split()[0]
        func = cols[0][6:]

        # 18003 read(255, "bin=`dirname ${bin}`\nbin=`cd \"$b"..., 5479) = 4614 <0.000040>
        # 18015 read(189, "[logging]\n default = FILE:/var/l"..., 8192) = 446 <0.000035>
        # 18015 open("/etc/timezone", O_RDONLY)   = -1 ENOENT (No such file or directory) <0.000060>
        if not retvalue.isdigit() and not retvalue[1:].isdigit():
            cols = line.split(') = ')
            print retvalue
            func = "%s)" % func

        #print "cols=%s" % (cols)
        #print "cols=%s retvalue=%s" % (cols, retvalue)
        retvalue = int(cols[1].split()[0])

        if "resumed" in line:
            print "resumed found: %s" % line

        else:
            sysname = cols[0].split('(')[0].split()[1]
            if sysname in sysCall: 
                retdata[pid], cline = line2c(sysname, func, retvalue, retdata[pid])
    
    if cline:
        if pid in sysdata.keys():
            sysdata[pid].append(cline)
        else:
            sysdata[pid] = [cline]

    return sysdata, retdata

def writeTable(outputFP, sysdata):
    keylist = sysdata.keys()
    keylist.sort()
    for pid in keylist:
        for line in sysdata[pid]:
            outputFP.write(line)

def convert(outputFile, inputFile, sysCall):
    sysdata = {}
    retdata = {}

    inputFP = open(inputFile, 'r')
    outputFP = open(outputFile, 'w')

    for line in inputFP:
        if line[0].isdigit() and not line.startswith("100") and not line.endswith("total\n"):
            sysdata, retdata = parseline(line, sysCall, sysdata, retdata)

    #pdb.set_trace()
    outputFP.write(cfilehead)
    writeTable(outputFP, sysdata)
    outputFP.write(cfiletail)

def help():
    print 'Usage: Sys2C.py [-h/--help] [-s/--syscall <syscall-list>]'
    print '                      -i <inputfile> -o <outputfile>'
    print '       [-s/--syscall <syscall-list>]: the syscall(s) to convert, devided by space'
    print '       -i <inputfile>: input file'
    print '       -o <outputfile>: output file'
    print 'i.e: Sys2C.py -s \"read read write open close lseek\" -i hadoop_w.data.file -o sys_file.c'

def main(argv):
    inputFile = ''
    outputFile = ''
    sysCall = sysFile # file management syscall by default

    try:
       opts, args = getopt.getopt(argv, "hs:i:o:", ["syscall=", "ifile=", "ofile="])
    except getopt.GetoptError:
       print 'Incorrect command format'
       help()
       sys.exit(2)
    if len(opts) == 0:
       print 'Insufficient arguments'
       help()
       sys.exit(2)
    for opt, arg in opts:
        if opt == '-h':
            help()
            sys.exit()
        elif opt in ("-s", "--syscall"):
            sysCall = arg.split()
        elif opt in ("-i", "--ifile"):
            inputFile = arg
        elif opt in ("-o", "--ofile"):
            outputFile = arg

    convert(outputFile, inputFile, sysCall)

if __name__ == "__main__":
    main(sys.argv[1:])
