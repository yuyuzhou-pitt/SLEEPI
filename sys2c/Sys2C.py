#!/usr/bin/python

import sys, getopt
import operator
import ntpath
import math
import pdb
import time
import re
import shutil
import os

testfile = ".testfile"
linkfile = ".linkfile"
notexistsfile = ".notexistsfile"

cfilehead = "/* Don't modify!! Automaticly generated by Sys2C.py. */\n\
#include <stdlib.h>\n\
/* for file management syscall */ \n\
#include <sys/types.h>\n\
#include <sys/stat.h>\n\
#include <fcntl.h>\n\
#include <unistd.h>\n\
/* for memory syscall */ \n\
#include <sys/mman.h>\n\
/* for INT_MAX */\n\
#include <limits.h>\n\
/* for sched_getaffinity / sched_setaffinity */\n\
#define _GNU_SOURCE             /* See feature_test_macros(7) */\n\
#include <sched.h>\n\
\n\
int main(void){\n\
/* default variables */\n\
int fd; // default fd (=3), for file management\n\
struct stat sb; // for stat\n\
char buf[INT_MAX]; // for read, write\n\
int currpid = getpid(); // for sched_getaffinity\n\
cpu_set_t *mask; // for sched_getaffinity / sched_setaffinity\n\
int *addr;\n\
addr = mmap(NULL, 97021, PROT_READ, MAP_SHARED, -1, 0);\n\
\n\
/* syscall begin */\n"

cfiletail = "/* syscall end */\nreturn 0;\n}"

# https://sites.google.com/site/alpil0000/linux-64-bit-system-call-list
sysText = open("syscall.list")
sysList = sysText.readlines()
sysDict = {}
for sysline in sysList:
    # 100 sysctl
    l2c_type = sysline[0:2]
    # ignore comment and skip un-using one
    if '#' != sysline[0] and '9' != sysline[0]:
        sysDict[sysline[4:].rstrip()] = l2c_type

def env_prep(filename):
    shutil.copyfile(filename, testfile)
    os.symlink(testfile, linkfile)

def env_clean():
    os.unlink(testfile)
    os.unlink(linkfile)

# convert directly
def l2c_100(func):
    return func

# replace all address
def l2c_addr_200(mmapaddr, func):
    return re.sub("0x[0-9a-f]*", "%s" % mmapaddr, func)   

# replace address in front
def l2c_addr_210(mmapaddr, func):
    return re.sub("\(0x[0-9a-f]*\,", "(%s," % mmapaddr, func)   

# replace fd
def l2c_fd_300(openfd, func):
    # 0 for stdin, 1 for stdout and 2 for stderr, and 255 for terminal I/O
    if re.search('(\(0\,|\(1\,|\(2\,|\(255\,)', func):
        return func
    else:
        return re.sub("\([0-9]*\,", "(%s," % openfd, func)

# replace string 
def l2c_str_400(filename, func):
    return re.sub("\"(.*)\"", "\"%s\"" % filename, func)

# replace pid
def l2c_pid_500(func):
    # 0 for stdin, 1 for stdout and 2 for stderr, and 255 for terminal I/O
    if re.search('(\(0\,)', func):
        return func
    else:
        return re.sub("\([0-9]*\,", "(currpid,", func)

# replace comment
def l2c_comment_600(string, func):
    return re.sub("\/\*(.*)\*\/", "%s" % string, func)

# replace struct
def l2c_struct_700(struct, func):
    return re.sub("\{(.*)\}", "%s" % struct, func)

def writeHisto(outHisto, outputFP):
    outputFP.write("{:12s}{:12s}{:12s}\t{:12s}\n" .format('HISTO:', 'syscall', 'times', 'seconds'))
    for keyT, valT in outHisto.items():
        sortedTable = sorted(valT.items(), key=operator.itemgetter(0), reverse=False)
        #print(sortedTable)
        for item in sortedTable:
            outputFP.write("{:12s}{:12s}{:10d}\t{:12s}\n" .format('HISTO:', keyT, item[1], item[0]))

def line2c(sysname, func, retvalue, retdata):
    funcline = ""
    timestr = re.sub("\.", "_", "%f" % time.time())

    #pdb.set_trace()
    if "openfd" in retdata.keys():
        openfd = retdata["openfd"]
    else:
        openfd = 255 # use a fake fd if not comes from open

    munmapaddr = ""
    mmapaddr = ""
    if "mmapaddr" in retdata.keys():
        munmapaddr = retdata["mmapaddr"] # for munmap
        mmapaddr = retdata["mmapaddr"] # for mmap with initial address or mprotect

    if "munmapaddr" in retdata.keys():
        munmapaddr = retdata["munmapaddr"] # for munmap

    # handle syscalls
    if "open" == sysname or "openat" == sysname:
        # fd = open("/sys/devices/system/cpu/online", O_RDONLY|O_CLOEXEC);
        func = l2c_str_400(testfile, func)
        if retvalue != -1:
            # set openfd for other syscalls
            retdata["openfd"] = openfd
            if retvalue != 3: # default fd is 3
                openfd = "fd_%s" % timestr
                funcline = "int %s = %s;\n" % (openfd, func)
            else:
                funcline = "fd = %s;\n" % func # use default fd
        else:
            # ret = -1
            func = l2c_str_200(notexistsfile, func)
            funcline = "%s;\n" % func
    elif "stat" == sysname or "lstat" == sysname: 
        # struct stat sb; stat("/usr/lib64/mpich/lib", &sb);
        #func = l2c_str_400(linkfile, func)
        func = l2c_addr_200("&sb", func)
        funcline = "%s;\n" % l2c_struct_700("&sb", func)
    elif "fstat" == sysname: 
        # struct stat sb; fstat(fd, &sb);
        funcline = "%s(%s, &sb);\n" % (sysname, openfd)
    elif "read" == sysname or "write" == sysname: 
        # char buf[SIZE]; read(fd, buf, SIZE);
        # char buf[SIZE]; write(fd, buf, SIZE);
        funcline = "%s(%s, buf, %s);\n" % (sysname, openfd, retvalue)
        # if re.search('(\(0\,|\(1\,|\(2\,|\(255\,)', func):
        #    funcline = "%s;\n" % func
    elif "getdents" == sysname:
        # getdents(3, /* 10 entries */, 32768)
        func = l2c_fd_300(openfd, func)
        func = l2c_comment_600("buf", func)
        funcline = "%s;\n" % func
    elif "close" == sysname: 
        # close(fd);
        # 0 for stdin, 1 for stdout and 2 for stderr, and 255 for terminal I/O
        if re.search('(\(0\)|\(1\)|\(2\)|\(255\))', func):
            funcline = "%s;\n" % func
        else:
            funcline = "%s(%s);\n" % (sysname, openfd)
            retdata.pop("openfd", None) # remove the openfd after closed
    elif "lseek" == sysname or "fcntl" == sysname or "chmod" == sysname:
        # lseek(3, 64428565, SEEK_SET);
        # fcntl(3, F_SETFD, FD_CLOEXEC);
        # 0 for stdin, 1 for stdout and 2 for stderr, and 255 for terminal I/O
        func = l2c_str_400(testfile, func)
        funcline = "%s;\n" % l2c_fd_300(openfd, func)
    elif "mmap" == sysname: 
        # char *char; char = mmap(NULL, 97021, PROT_READ, MAP_PRIVATE, 3, 0);
        # update the fd
        funclist = func.split(',')
        if funclist[-2] != '-1':
            funclist[-2] = str(openfd)
            func = ', '.join(funclist)

        # store mapped address
        if re.search('NULL', func):
            mmapaddr = "addr_%s" % timestr
            retdata["munmapaddr"] = mmapaddr # for munmap
            retdata["mmapaddr"] = mmapaddr
            funcline = "char *%s; %s = %s;\n" % (mmapaddr, mmapaddr, func)
        else:
            if not mmapaddr:
                mmapaddr = "addr_%s" % timestr
                func = l2c_addr_210("NULL", func)
                retdata["mmapaddr"] = mmapaddr
                funcline = "char *%s; %s = %s;\n" % (mmapaddr, mmapaddr, func)
            else:
                # no new variable defined if alread exists
                #print func
                funcline = "%s;\n" % l2c_addr_210(mmapaddr, func)
    elif "munmap" == sysname or "mprotect" == sysname:
        if munmapaddr:
            funcline = "%s;\n" % l2c_addr_210(munmapaddr, func)
            retdata.pop("munmapaddr", None) # remove after unmmap
        elif mmapaddr:
            funcline = "%s;\n" % l2c_addr_210(mmapaddr, func)
        else:
            funcline = "%s;\n" % l2c_addr_210("addr", func)
            #print "ERROR: no addrss to unmap or mprotect"
    elif "execve" == sysname: 
        # execve("/usr/bin/which", ["which", "/home/yuyuzhou/Hadoop/hadoop-2.6"...], [/* 54 vars */])
        funclist = func.split(',')
        if funclist[-2] != '-1':
            funclist[-2] = str(openfd)
            func = ', '.join(funclist)

        if re.search('\.\.\.\,', func): # those takes about 600us in strace
            funcline = "execve(\"/sbin/sysctl\", [\"/sbin/sysctl\", \"-n\", \
                       \"net.ipv6.bindv6only\"], [/* 68 vars */]);\n"
        else:
            funcline = "%s;\n" % func
    elif "sched_getaffinity" == sysname:
        func = l2c_struct_700("mask", func)
        funcline = "%s;\n" % l2c_pid_500(func)
    elif "100" == sysDict[sysname]: 
        funcline = "%s;\n" % l2c_100(func)
    elif "200" == sysDict[sysname]: 
        funcline = "%s;\n" % l2c_addr_200(mmapaddr, func)
    elif "300" == sysDict[sysname]: 
        funcline = "%s;\n" % l2c_fd_300(openfd, func)

    #elif "creat" == sysname: 
    #elif "fchmod" == sysname: 
    #elif "fchmodat" == sysname: 
        
    return retdata, funcline

def parseline(line, sysCall, sysdata, retdata):
    cline = ""

    pid = line[0:5]
    line = line[6:]
    if pid not in retdata:
        retdata[pid] = {} # each pid has it's own openfd, mmapaddr, and etc.

    if "unfinished" in line:
        #print "unfinished found: %s" % line
        retdata[pid]['unfinished'] = (line.split('<unfinished ...>'))[0]

    else:
        #pdb.set_trace()
        # combine the unfinished and resumed to one line
        if "resumed" in line:
            #print "resumed found: %s" % line
            lineresumed = (line.split('resumed>'))[1]
            line = "%s %s" % (retdata[pid]['unfinished'], lineresumed)

        cols = line.split(' = ')
        #print "cols_a =%s.\n" % cols
        retvalue = cols[1].split()[0]
        func = cols[0]

        # 18003 read(255, "bin=`dirname ${bin}`\nbin=`cd \"$b"..., 5479) = 4614 <0.000040>
        # 18015 read(189, "[logging]\n default = FILE:/var/l"..., 8192) = 446 <0.000035>
        # 18015 open("/etc/timezone", O_RDONLY)   = -1 ENOENT (No such file or directory) <0.000060>
        #cols=['brk(0)                            = 0x1e60000 <0.000025>\n
        #exit_group(0)                     = ?
        if not retvalue[0] == "?" and not retvalue[0:2] == "0x" \
           and not retvalue.isdigit() and not retvalue[1:].isdigit():
            #print retvalue
            cols = line.split(') = ')
            func = "%s)" % cols[0]
            retvalue = cols[1].split()[0]

        #print "cols_b =%s.\n" % cols
        #retvalue = int(cols[1].split()[0])

        sysname = cols[0].split('(')[0]
        if sysname in sysCall:     
            retdata[pid], cline = line2c(sysname, func, retvalue, retdata[pid])

    if cline:
        if pid in sysdata.keys():
            sysdata[pid].append(cline)
        else:
            sysdata[pid] = [cline]

    return sysdata, retdata

def writeTable(outputFP, sysdata):
    keylist = sysdata.keys()
    keylist.sort()
    for pid in keylist:
        for line in sysdata[pid]:
            outputFP.write(line)

def convert(outputFile, inputFile, sysCall):
    sysdata = {}
    retdata = {}

    inputFP = open(inputFile, 'r')
    outputFP = open(outputFile, 'w')

    for line in inputFP:
        if line[0].isdigit() and not line.startswith("100") and not line.endswith("total\n") \
          and not line[6:9] == '+++' and not line[6:9] == '---':
            # 18284 +++ exited with 0 +++
            # 18015 --- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_ACCERR, si_addr=0x7fbe8c256100} ---
            # % time     seconds  usecs/call     calls    errors syscall
            # ------ ----------- ----------- --------- --------- ----------------
            #  95.04  143.863892        6842     21026      3277 futex
            # 100.00  151.365480                446922     10674 total
            sysdata, retdata = parseline(line, sysCall, sysdata, retdata)

    #pdb.set_trace()
    outputFP.write(cfilehead)
    writeTable(outputFP, sysdata)
    outputFP.write(cfiletail)

def help():
    print 'Usage: Sys2C.py [-h/--help] [-s/--syscall <syscall-list>]'
    print '                      -i <inputfile> -o <outputfile>'
    print '       [-s/--syscall <syscall-list>]: the syscall(s) to convert, devided by space'
    print '       -i <inputfile>: input file'
    print '       -o <outputfile>: output file'
    print 'i.e: Sys2C.py -s \"read read write open close lseek\" -i hadoop_w.data.file -o sys_file.c'

def main(argv):
    inputFile = ''
    outputFile = ''
    sysCall = sysDict.keys() # all syscall by default

    try:
       opts, args = getopt.getopt(argv, "hs:i:o:", ["syscall=", "ifile=", "ofile="])
    except getopt.GetoptError:
       print 'Incorrect command format'
       help()
       sys.exit(2)
    if len(opts) == 0:
       print 'Insufficient arguments'
       help()
       sys.exit(2)
    for opt, arg in opts:
        if opt == '-h':
            help()
            sys.exit()
        elif opt in ("-s", "--syscall"):
            sysCall = arg.split()
        elif opt in ("-i", "--ifile"):
            inputFile = arg
        elif opt in ("-o", "--ofile"):
            outputFile = arg

    env_prep(inputFile)
    convert(outputFile, inputFile, sysCall)
    env_clean()

if __name__ == "__main__":
    main(sys.argv[1:])
