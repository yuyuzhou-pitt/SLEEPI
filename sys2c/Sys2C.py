#!/usr/bin/python
# convert syscall (generated by strace) to c code
# e.g.: 
# $ numactl -N 0 -m 0 strace -s 256 -o ~/data/hadoop_w_full.data -CTf numactl -N 0 -m 0 $HADOOP_HOME/bin/hadoop jar $HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.6.0.jar grep $HADOOP_HOME/input $HADOOP_HOME/output '[a-z.]+' 
# $ python Sys2C.py -i ~/data/hadoop_w_full.data -o sysfile.c

import sys, getopt
import operator
import ntpath
import math
import pdb
import time
import re
import shutil
import os

cfilehead = "/* Don't modify!! Automaticly generated by Sys2C.py. */\n\
/* Steps to build and run: */\n\
/* $ gcc  -g3 -o sysfile sysfile.c */\n\
/* $ ./sysfile */\n\
\n\
/* BUFSIZ */\n\
#include <stdio.h>\n\
#include <stdlib.h>\n\
/* for file management syscall */ \n\
#include <sys/types.h>\n\
#include <sys/stat.h>\n\
#include <fcntl.h>\n\
#include <unistd.h>\n\
#include <linux/unistd.h>\n\
/* for memory syscall */ \n\
#include <sys/mman.h>\n\
/* for INT_MAX */\n\
#include <limits.h>\n\
/* for sched_getaffinity / sched_setaffinity */\n\
#define _GNU_SOURCE             /* See feature_test_macros(7) */\n\
#include <sched.h>\n\
/* for signals */\n\
#include <signal.h>\n\
/* for socket */\n\
#include <sys/types.h>\n\
#include <sys/socket.h>\n\
#include <netinet/in.h>\n\
/* for arch_prctl */\n\
#include <asm/prctl.h>\n\
#include <sys/prctl.h>\n\
/* for set_mempolicy */\n\
#include <numaif.h>\n\
#include <numa.h>\n\
/* For getdents */\n\
#include <sys/dir.h>\n\
#include <dirent.h>\n\
/* For set_robust_list */\n\
#include <linux/futex.h>\n\
#include <syscall.h>\n\
/* For buf */\n\
#define BSIZE 1048576\n\
\n\
int main(void){\n\
\n\
/* default variables */\n\
int fd; // default fd (=3), for file management\n\
struct stat sb; // for stat\n\
char buf[BSIZE]; // for read, write\n\
char *dents; // for getdirentries\n\
int currpid = getpid(); // for sched_getaffinity\n\
cpu_set_t *mask; // for sched_getaffinity / sched_setaffinity\n\
char *addr = NULL;\n\
addr = mmap(NULL, 256*BUFSIZ, PROT_READ, MAP_ANON|MAP_SHARED, -1, 0);\n\
\n\
/* syscall begin */\n"

cfiletail = "/* syscall end */\nexit(0);\n}"

# https://sites.google.com/site/alpil0000/linux-64-bit-system-call-list
sysText = open("syscall.list")
sysList = sysText.readlines()
sysDict = {}
for sysline in sysList:
    # 100 sysctl
    l2c_type = sysline[0:3]
    # ignore comment and skip un-using one
    if '#' != sysline[0] and '9' != sysline[0]:
        sysDict[sysline[4:].rstrip()] = l2c_type

# convert directly
def l2c_100(func):
    return func

# replace all address
def l2c_addr_200(mmapaddr, func):
    return re.sub("0x[0-9a-f]*", "%s" % mmapaddr, func)   

# replace address in front
def l2c_addr_201(addrdict, addrstr, func):
    # for munmap. mprotect
    addrhex = "0x0"
    addrreg = "0x[0-9a-f]*"
    addrgroup = re.search(addrreg, func)
    if addrgroup:
        addrhex = addrgroup.group(0)
        if addrhex in addrdict:
            addrstr = addrdict[addrhex]
        else:
            addrstr = "addr" # arbitary memory can not be use to mmap

    func = re.sub("\(%s" % addrreg, "(%s" % addrstr, func)
    return addrhex, func

# replace fd
def l2c_fd_300(openfd, func):
    # 0 for stdin, 1 for stdout and 2 for stderr, and 255 for terminal I/O
    if re.search('(\(0\,|\(1\,|\(2\,|\(255\,)', func):
        return func
    else:
        return re.sub("\([0-9]*\,", "(%s," % openfd, func)

# replace string 
def l2c_str_400(filename, func):
    return re.sub("\"(.*)\"", "\"%s\"" % filename, func)

# replace pid
def l2c_pid_500(func):
    # 0 for stdin, 1 for stdout and 2 for stderr, and 255 for terminal I/O
    if re.search('(\(0\,)', func):
        return func
    else:
        return re.sub("\([0-9]*\,", "(currpid,", func)

# replace comment
def l2c_comment_600(string, func):
    return re.sub("\/\*(.*)\*\/", "%s" % string, func)

# replace struct
def l2c_struct_700(struct, func):
    return re.sub("\{(.*)\}", "%s" % struct, func)

# replace struct with void*
def l2c_struct_701(func, timestr):
    #struct = re.search('\{(.*)\}', func)
    struct = ""
    if struct:
        func = re.sub("\{(.*)\}", "buf_%s" % timestr, func)
        return "void *buf_%s = %s; %s;\n" % (timestr, struct.group(0), func)
    else:
        func = re.sub("\{(.*)\}", "buf", func)
        return "%s;\n" % func

# replace argv
def l2c_argv_800(strarray, func):
    # ["setsid", "bash", "-c", "echo $$"]
    return re.sub("\[\"(.*)\"\]", "%s" % strarray, func)

# replace argv in comments
def l2c_argv_801(strarray, func):
    # [/* 75 vars */]
    return re.sub("\[\/\*(.*)\*\/\]", "%s" % strarray, func)

# replace argv in number
def l2c_argv_802(strarray, func):
    # [/* 75 vars */]
    return re.sub("\[[0-9\,\ ]*\]", "%s" % strarray, func)

def writeHisto(outHisto, outputFP):
    outputFP.write("{:12s}{:12s}{:12s}\t{:12s}\n" .format('HISTO:', 'syscall', 'times', 'seconds'))
    for keyT, valT in outHisto.items():
        sortedTable = sorted(valT.items(), key=operator.itemgetter(0), reverse=False)
        #print(sortedTable)
        for item in sortedTable:
            outputFP.write("{:12s}{:12s}{:10d}\t{:12s}\n" .format('HISTO:', keyT, item[1], item[0]))

def line2c(sysname, func, retvalue, retdata):
    funcline = ""
    #pdb.set_trace()
    munmapdict = {}
    if "munmapaddr" not in retdata:
        retdata["munmapaddr"] = {} # to match the mmap, munmap  pair
    else:
        munmapdict = retdata["munmapaddr"]

    timestr = re.sub("\.", "_", "%f" % time.time())

    #pdb.set_trace()
    if "openfd" in retdata.keys():
        openfd = retdata["openfd"]
    else:
        openfd = 255 # use a fake fd if not comes from open

    munmapaddr = ""
    mmapaddr = ""
    if "mmapaddr" in retdata.keys():
        #munmapaddr = retdata["mmapaddr"] # for munmap
        mmapaddr = retdata["mmapaddr"] # for mmap with initial address or mprotect

    if retvalue in munmapdict:
        munmapaddr = munmapdict[retvalue] # for munmap

    # handle syscalls
    if "open" == sysname or "openat" == sysname:
        # fd = open("/sys/devices/system/cpu/online", O_RDONLY|O_CLOEXEC);
        #func = l2c_str_400(testfile, func)
        if retvalue != -1:
            # set openfd for other syscalls
            if retvalue != 3: # default fd is 3
                openfd = "fd_%s" % timestr
                retdata["openfd"] = openfd
                funcline = "int %s = %s;\n" % (openfd, func)
            else:
                funcline = "fd = %s;\n" % func # use default fd
        else:
            # ret = -1
            #func = l2c_str_200(notexistsfile, func)
            funcline = "%s;\n" % func
    elif "stat" == sysname or "lstat" == sysname: 
        # struct stat sb; stat("/usr/lib64/mpich/lib", &sb);
        #func = l2c_str_400(linkfile, func)
        func = l2c_addr_200("&sb", func)
        funcline = "%s;\n" % l2c_struct_700("&sb", func)
    elif "fstat" == sysname: 
        # struct stat sb; fstat(fd, &sb);
        funcline = "%s(%s, &sb);\n" % (sysname, openfd)
    elif "read" == sysname or "write" == sysname: 
        # char buf[SIZE]; read(fd, buf, SIZE);
        # char buf[SIZE]; write(fd, buf, SIZE);
        funcline = "if (%s != -1) %s(%s, buf, %s);\n" % (openfd, sysname, openfd, retvalue)
        #funcline = "char buf_%s[%s]; %s(%s, buf_%s, %s);\n" % \
        #           (timestr, retvalue, sysname, openfd, timestr, retvalue)
        # if re.search('(\(0\,|\(1\,|\(2\,|\(255\,)', func):
        #    funcline = "%s;\n" % func
    elif "getdents" == sysname:
        # getdents(3, /* 10 entries */, 32768)
        func = re.sub("getdents", "getdirentries", func)
        func = re.sub("\)", ", 0)", func)
        func = l2c_fd_300(openfd, func)
        func = l2c_comment_600("dents", func)
        funcline = "%s;\n" % func
    elif "close" == sysname: 
        # close(fd);
        # 0 for stdin, 1 for stdout and 2 for stderr, and 255 for terminal I/O
        if re.search('(\(0\)|\(1\)|\(2\)|\(255\))', func):
            funcline = "%s;\n" % func
        else:
            funcline = "if (%s != -1) %s(%s);\n" % (openfd, sysname, openfd)
            retdata.pop("openfd", None) # remove the openfd after closed
    elif "lseek" == sysname or "fcntl" == sysname or "chmod" == sysname:
        # lseek(3, 64428565, SEEK_SET);
        # fcntl(3, F_SETFD, FD_CLOEXEC);
        # 0 for stdin, 1 for stdout and 2 for stderr, and 255 for terminal I/O
        #func = l2c_str_400(testfile, func)
        funcline = "%s;\n" % l2c_fd_300(openfd, func)
    elif "mmap" == sysname: 
        # char *char; char = mmap(NULL, 97021, PROT_READ, MAP_PRIVATE, 3, 0);
        # update the fd
        funclist = func.split(',')
        if funclist[-2].strip() != "-1":
            funclist[-2] = str(openfd)
            func = ', '.join(funclist)

        # remove MAP_FIXED when mmap, or segfault happens
        if re.search('MAP_FIXED', func):
            func = re.sub("\|MAP_FIXED", "", func)

        # deal with those without NULL address
        if not re.search('NULL', func):
            addrhex, func = l2c_addr_201(munmapdict, "addr", func)

        # store mapped address
        mmapaddr = "addr_%s" % timestr
        retdata["mmapaddr"] = mmapaddr
        munmapdict[retvalue] = mmapaddr # for munmap
        retdata["munmapaddr"] = munmapdict

        #if func:
        #   funcline = "char *%s; %s = %s;\n" % (mmapaddr, mmapaddr, func)
        funcline = "char *%s; %s = %s;\n" % (mmapaddr, mmapaddr, func)
    elif "sched_" in sysname:
        func = l2c_struct_700("mask", func)
        funcline = "%s;\n" % l2c_pid_500(func)
    elif "ioctl" == sysname:
        func = l2c_fd_300(openfd, func)
        func = "void *arg_%s; %s;\n" % \
               (timestr, l2c_argv_802("arg_%s" % timestr, func))
    elif "clock_" in sysname: # clock_getres, clock_gettime, clock_settime
        # clock_getres(CLOCK_MONOTONIC, {0, 1});
        func = "struct timespec *tp_%s; %s;\n" % (timestr, l2c_struct_700("tp_%s" % timestr, func))
    elif "rt_sig" in sysname:
        func = "struct sigaction *act_%s; %s;\n" % (timestr, l2c_struct_700("act_%s" % timestr, func))
    elif "wait" in sysname:
        func = "int *status_%s; %s;\n" % (timestr, l2c_struct_700("status_%s" % timestr, func))
    elif "uname" == sysname:
        func = "struct utsname *buf_%s; %s;\n" % (timestr, l2c_struct_700("buf_%s" % timestr, func))
    elif "connect" == sysname:
        struct = re.search('\{(.*)\}', func)
        func = "struct sockaddr *sock_%s = %s; %s;\n" % (timestr, struct.group(0), l2c_struct_700("sock_%s" % timestr, func))
    elif "rlimit" in sysname:
        struct = re.search('\{(.*)\}', func)
        func = "struct rlimit *rlim_%s = %s; %s;\n" % (timestr, struct.group(0), l2c_struct_700("rlim_%s" % timestr, func))
    elif "100" == sysDict[sysname]: 
        funcline = "%s;\n" % l2c_100(func)
    elif "201" == sysDict[sysname]: 
        #pdb.set_trace()
        #if "brk(0x" in func:
        #    pdb.set_trace()
        if munmapaddr:
            addrhex, func = l2c_addr_201(munmapdict, munmapaddr, func)
            if "munmap" == sysname:
                munmapdict.pop(addrhex, None)  # remove after unmmap
                retdata["munmapaddr"] = munmapdict 
        #elif mmapaddr:
        #    addrhex, func = l2c_addr_201(munmapdict, mmapaddr, func)
        #    funcline = "%s;\n" % func
        else:
            addrhex, func = l2c_addr_201(munmapdict, "addr", func)

        if "void" in func:
            func = "" # arbitary memory can not be munmap/mprotect

        if "munmap(addr," in func:
            func = "" # do not unmap the dummy addr

        funcline = "%s;\n" % func
    elif "200" == sysDict[sysname]:
        if munmapaddr:
            funcline = "%s;\n" % l2c_addr_200(munmapaddr, func)
            munmapdict.pop(retvalue, None)  # remove after unmmap
            retdata["munmapaddr"] = munmapdict
        elif mmapaddr:
            funcline = "%s;\n" % l2c_addr_200(mmapaddr, func)
        else:
            funcline = "%s;\n" % l2c_addr_200("addr", func)
    elif "300" == sysDict[sysname]: 
        funcline = "%s;\n" % l2c_fd_300(openfd, func)
    elif "701" == sysDict[sysname]: 
        funcline = l2c_struct_701(func, timestr)
    elif "700" == sysDict[sysname]: 
        funcline = "%s;\n" % l2c_struct_700("buf", func)
    elif "280" == sysDict[sysname]: 
        func = l2c_addr_200(mmapaddr, func)
        funcline = "if(mmapaddr) {void *arg_%s; %s;}\n" % (timestr, l2c_argv_802("arg_%s" % timestr, func))

    #elif "creat" == sysname: 
    #elif "fchmod" == sysname: 
    #elif "fchmodat" == sysname: 
        
    if "buf;" in funcline:
        print "func=%s;funcline=%s.\n" % (func, funcline)
    return retdata, funcline

def parseline(line, sysCall, sysdata, retdata):
    cline = ""

    pid = line[0:5]
    line = line[6:]
    if pid not in retdata:
        retdata[pid] = {} # each pid has it's own openfd, mmapaddr, and etc.

    if "unfinished" in line:
        #print "unfinished found: %s" % line
        retdata[pid]['unfinished'] = (line.split('<unfinished ...>'))[0]

    else:
        #pdb.set_trace()
        # combine the unfinished and resumed to one line
        if " resumed> " in line:
            #print "resumed found: %s" % line
            lineresumed = (line.split(' resumed> '))[1]
            line = "%s %s" % (retdata[pid]['unfinished'], lineresumed)

        cols = line.split(' = ')
        #print "cols_a =%s.\n" % cols
        retvalue = cols[-1].split()[0]
        func = cols[0]

        # 18003 read(255, "bin=`dirname ${bin}`\nbin=`cd \"$b"..., 5479) = 4614 <0.000040>
        # 18015 read(189, "[logging]\n default = FILE:/var/l"..., 8192) = 446 <0.000035>
        # 18015 open("/etc/timezone", O_RDONLY)   = -1 ENOENT (No such file or directory) <0.000060>
        #cols=['brk(0)                            = 0x1e60000 <0.000025>\n
        #exit_group(0)                     = ?
        if not retvalue[0] == "?" and not retvalue[0:2] == "0x" \
           and not retvalue.isdigit() and not retvalue[1:].isdigit():
            #print retvalue
            #pdb.set_trace()
            cols = line.split(') = ')
            func = "%s)" % cols[0]
            # retvalue is in the last one as below condition:
            # write(2, "15/02/03 18:01:27 INFO mapred.MapTask: 
            # bufstart = 0; bufvoid = 104857600\\n", 73) = 73 <0.000040>\n
            retvalue = cols[-1].split()[0]

        sysname = cols[0].split('(')[0]
        if sysname in sysCall:     
            retdata[pid], cline = line2c(sysname, func, retvalue, retdata[pid])

    if cline:
        if pid in sysdata.keys():
            sysdata[pid].append(cline)
        else:
            sysdata[pid] = [cline]

    return sysdata, retdata

def writeTable(outputFP, sysdata):
    keylist = sysdata.keys()
    keylist.sort()
    for pid in keylist:
        for line in sysdata[pid]:
            outputFP.write(line)

def convert(outputFile, inputFile, sysCall):
    sysdata = {}
    retdata = {}

    #pdb.set_trace()
    inputFP = open(inputFile, 'r')
    outputFP = open(outputFile, 'w')

    for line in inputFP:
        if line[0].isdigit() and not line.startswith("100") and not line.endswith("total\n") \
          and not line[6:9] == '+++' and not line[6:9] == '---':
            # 18284 +++ exited with 0 +++
            # 18015 --- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_ACCERR, si_addr=0x7fbe8c256100} ---
            # % time     seconds  usecs/call     calls    errors syscall
            # ------ ----------- ----------- --------- --------- ----------------
            #  95.04  143.863892        6842     21026      3277 futex
            # 100.00  151.365480                446922     10674 total
            sysdata, retdata = parseline(line, sysCall, sysdata, retdata)

    #pdb.set_trace()
    outputFP.write(cfilehead)
    writeTable(outputFP, sysdata)
    outputFP.write(cfiletail)

def help():
    print 'Usage: Sys2C.py [-h/--help] [-s/--syscall <syscall-list>]'
    print '                      -i <inputfile> -o <outputfile>'
    print '       [-s/--syscall <syscall-list>]: the syscall(s) to convert, devided by space'
    print '       -i <inputfile>: input file'
    print '       -o <outputfile>: output file'
    print 'i.e: Sys2C.py -s \"read read write open close lseek\" -i hadoop_w.data.file -o sys_file.c'

def main(argv):
    inputFile = ''
    outputFile = ''
    sysCall = sysDict.keys() # all syscall by default

    try:
       opts, args = getopt.getopt(argv, "hs:i:o:", ["syscall=", "ifile=", "ofile="])
    except getopt.GetoptError:
       print 'Incorrect command format'
       help()
       sys.exit(2)
    if len(opts) == 0:
       print 'Insufficient arguments'
       help()
       sys.exit(2)
    for opt, arg in opts:
        if opt == '-h':
            help()
            sys.exit()
        elif opt in ("-s", "--syscall"):
            sysCall = arg.split()
        elif opt in ("-i", "--ifile"):
            inputFile = arg
        elif opt in ("-o", "--ofile"):
            outputFile = arg

    convert(outputFile, inputFile, sysCall)

if __name__ == "__main__":
    main(sys.argv[1:])
